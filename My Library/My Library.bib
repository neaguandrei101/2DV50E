
@inreference{wikipedia_generation_nodate,
	title = {Generation --- \{W\}ikipedia\{,\} The Free Encyclopedia},
	url = {https://en.wikipedia.org/wiki/Generation#Western_world},
	author = {Wikipedia},
	urldate = {2021-02-16},
}

@misc{noauthor_notitle_nodate,
}

@article{noauthor_notitle_nodate-1,
}

@article{sabir_systematic_2019,
	title = {A systematic literature review on the detection of smells and their evolution in object-oriented and service-oriented systems},
	volume = {49},
	issn = {00380644},
	url = {http://doi.wiley.com/10.1002/spe.2639},
	doi = {10.1002/spe.2639},
	abstract = {This systematic literature review paper investigates the key techniques employed to identify smells in different paradigms of software engineering from object-oriented ({OO}) to service-oriented ({SO}). In this review, we want to identify commonalities and differences in the identification of smells in {OO} and {SO} systems. Our research method relies on an automatic search from the relevant digital libraries to find the studies published since January 2000 on smells until December 2017. We have conducted a pilot and author-based search that allows us to select the 78 most relevant studies after applying inclusion and exclusion criteria. We evaluated the studies based on the smell detection techniques and the evolution of different methodologies in {OO} and {SO}. Among the 78 relevant studies selected, we have identified six different studies in which linguistic source code analysis received less attention from the researchers as compared to the static source code analysis. Smells like the yo-yo problem, unnamed coupling, intensive coupling, and interface bloat received considerably less attention in the literature. We also identified a catalog of 30 smells infrequently reported for {SO} systems and that require further attention. Moreover, a suite of 20 smells reported for {SO} systems can also be detected using static source code metrics in {OO}. Finally, our review highlighted three major research trends that are further subdivided into 20 research patterns initiating the detection of smells toward their correction.},
	pages = {3--39},
	number = {1},
	journaltitle = {Softw: Pract Exper},
	author = {Sabir, Fatima and Palma, Francis and Rasool, Ghulam and Guéhéneuc, Yann-Gaël and Moha, Naouel},
	urldate = {2021-02-18},
	date = {2019-01},
	langid = {english},
	file = {Sabir et al. - 2019 - A systematic literature review on the detection of.pdf:files/4/Sabir et al. - 2019 - A systematic literature review on the detection of.pdf:application/pdf},
}

@article{wolke_question_nodate,
	title = {Question time \& workshop},
	pages = {38},
	author = {Wolke, Anna},
	langid = {english},
	file = {Wolke - Question time & workshop.pdf:files/7/Wolke - Question time & workshop.pdf:application/pdf},
}

@article{sabir_systematic_2019-1,
	title = {A systematic literature review on the detection of smells and their evolution in object-oriented and service-oriented systems},
	volume = {49},
	issn = {00380644},
	url = {http://doi.wiley.com/10.1002/spe.2639},
	doi = {10.1002/spe.2639},
	abstract = {This systematic literature review paper investigates the key techniques employed to identify smells in different paradigms of software engineering from object-oriented ({OO}) to service-oriented ({SO}). In this review, we want to identify commonalities and differences in the identification of smells in {OO} and {SO} systems. Our research method relies on an automatic search from the relevant digital libraries to find the studies published since January 2000 on smells until December 2017. We have conducted a pilot and author-based search that allows us to select the 78 most relevant studies after applying inclusion and exclusion criteria. We evaluated the studies based on the smell detection techniques and the evolution of different methodologies in {OO} and {SO}. Among the 78 relevant studies selected, we have identified six different studies in which linguistic source code analysis received less attention from the researchers as compared to the static source code analysis. Smells like the yo-yo problem, unnamed coupling, intensive coupling, and interface bloat received considerably less attention in the literature. We also identified a catalog of 30 smells infrequently reported for {SO} systems and that require further attention. Moreover, a suite of 20 smells reported for {SO} systems can also be detected using static source code metrics in {OO}. Finally, our review highlighted three major research trends that are further subdivided into 20 research patterns initiating the detection of smells toward their correction.},
	pages = {3--39},
	number = {1},
	journaltitle = {Softw: Pract Exper},
	author = {Sabir, Fatima and Palma, Francis and Rasool, Ghulam and Guéhéneuc, Yann-Gaël and Moha, Naouel},
	urldate = {2021-02-18},
	date = {2019-01},
	langid = {english},
}

@article{yasin_using_2020,
	title = {On Using Grey Literature and Google Scholar in Systematic Literature Reviews in Software Engineering},
	volume = {8},
	issn = {2169-3536},
	doi = {10.1109/ACCESS.2020.2971712},
	abstract = {Context: The inclusion of grey literature ({GL}) is important to remove publication bias while gathering available evidence regarding a certain topic. The number of systematic literature reviews ({SLRs}) in Software Engineering ({SE}) is increasing but we do not know about the extent of {GL} usage in these {SLRs}. Moreover, Google Scholar is rapidly becoming a search engine of choice for many researchers but the extent to which it can find the primary studies is not known. Objective: This tertiary study is an attempt to i) measure the usage of {GL} in {SLRs} in {SE}. Furthermore this study proposes strategies for categorizing {GL} and a quality checklist to use for {GL} in future {SLRs}; ii) explore if it is feasible to use only Google Scholar for finding scholarly articles for academic research. Method: We have conducted a systematic mapping study to measure the extent of {GL} usage in {SE} {SLRs} as well as to measure the feasibility of finding primary studies using Google Scholar. Results and conclusions: a) Grey Literature: 76.09\% {SLRs} (105 out of 138) in {SE} have included one or more {GL} studies as primary studies. Among total primary studies across all {SLRs} (6307), 582 are classified as {GL}, making the frequency of {GL} citing as 9.23\%. The intensity of {GL} use indicate that each {SLR} contains 5 primary studies on average (total intensity of {GL} use being 5.54). The ranking of {GL} tells us that conference papers are the most used form 43.3\% followed by technical reports 28.52\%. Universities, research institutes, labs and scientific societies together make up 67.7\% of {GL} used, indicating that these are useful sources for searching {GL}. We additionally propose strategies for categorizing {GL} and criteria for evaluating {GL} quality, which can become a basis for more detailed guidelines for including {GL} in future {SLRs}. b) Google Scholar Results: The results show that Google Scholar was able to retrieve 96\% of primary studies of these {SLRs}. Most of the primary studies that were not found using Google Scholar were from grey sources.},
	pages = {36226--36243},
	journaltitle = {{IEEE} Access},
	author = {Yasin, A. and Fatima, R. and Wen, L. and Afzal, W. and Azhar, M. and Torkar, R.},
	date = {2020},
	note = {Conference Name: {IEEE} Access},
	keywords = {Bibliographies, Databases, empirical evaluation, Google, Google scholar, Google Scholar, gray, grey literature, Grey literature, grey systems, Guidelines, Internet, quality checklist, search engine, search engines, software engineering, Software engineering, Software Engineering, software reviews, systematic literature reviews, systematic mapping, systematic mapping study, Systematics, tertiary study},
	file = {IEEE Xplore Full Text PDF:files/13/Yasin et al. - 2020 - On Using Grey Literature and Google Scholar in Sys.pdf:application/pdf;IEEE Xplore Abstract Record:files/14/8984351.html:text/html},
}

@inproceedings{yip_software_1994,
	title = {A software maintenance survey},
	doi = {10.1109/APSEC.1994.465272},
	abstract = {We have conducted a survey of the state of software maintenance in Hong Kong, as the software industry in Hong Kong and south China is expanding. The survey instrument is derived from the previous work of Lientz and Swanson (1981) and Dekleva (1992). We sent out about 1000 questionnaires and received about 5\% replies. Our results indicate that, in Hong Kong, about 66\% of the total software life cycle cost is spent on software maintenance. The average application system is about 5 years old, consisting of 577 programs and 308000 lines of code. Making enhancements appears to be the most costly group of maintenance work (38\% of all maintenance work undertaken), followed by error correction (16\%). The most often cited problems in software maintenance are staff turnover, poor documentation and changing user requirements.{\textless}{\textgreater}},
	eventtitle = {Proceedings of 1st Asia-Pacific Software Engineering Conference},
	pages = {70--79},
	booktitle = {Proceedings of 1st Asia-Pacific Software Engineering Conference},
	author = {Yip, S. W. L. and Lam, T.},
	date = {1994-12},
	keywords = {Airports, application system age, Banking, changing user requirements, Computer industry, Costs, {DP} industry, enhancements, error correction, Error correction, Finance, Government, Hong Kong, Instruments, personnel, poor documentation, questionnaires, reviews, software industry, software life cycle cost, software maintenance, Software maintenance, software maintenance survey, software management, Software performance, south China, staff turnover, system documentation},
	file = {IEEE Xplore Abstract Record:files/17/465272.html:text/html},
}

@inproceedings{sousa_survey_1998,
	title = {A survey on the Software Maintenance Process},
	doi = {10.1109/ICSM.1998.738518},
	abstract = {This research paper presents the results of a field survey for the characterisation of Software Maintenance Process in Portugal. It was concluded that the three biggest problems related to the Software Maintenance Process are: the lack of software maintenance process models, the lack of documentation of applications and the lack of time to satisfy the requests. Only 2.7\% of the people who answered the questionnaire consider the software maintenance process very efficient; 70.2\% consider it of a very low level of efficiency.},
	eventtitle = {Proceedings. International Conference on Software Maintenance (Cat. No. 98CB36272)},
	pages = {265--274},
	booktitle = {Proceedings. International Conference on Software Maintenance (Cat. No. 98CB36272)},
	author = {Sousa, M. J. C. and Moreira, H. M.},
	date = {1998-11},
	note = {{ISSN}: 1063-6773},
	keywords = {Error correction, software maintenance, Software maintenance, Software performance, Application software, characterisation, Computational efficiency, Documentation, field survey, Hardware, Portugal, Preventive maintenance, process models, software maintenance process, software process improvement, Software standards, Telephony},
	file = {IEEE Xplore Abstract Record:files/19/738518.html:text/html;Daniel Toll template.docx:files/23/Daniel Toll template.docx:application/vnd.openxmlformats-officedocument.wordprocessingml.document},
}

@article{brereton_lessons_2007,
	title = {Lessons from applying the systematic literature review process within the software engineering domain},
	volume = {80},
	issn = {0164-1212},
	url = {https://www.sciencedirect.com/science/article/pii/S016412120600197X},
	doi = {10.1016/j.jss.2006.07.009},
	series = {Software Performance},
	abstract = {A consequence of the growing number of empirical studies in software engineering is the need to adopt systematic approaches to assessing and aggregating research outcomes in order to provide a balanced and objective summary of research evidence for a particular topic. The paper reports experiences with applying one such approach, the practice of systematic literature review, to the published studies relevant to topics within the software engineering domain. The systematic literature review process is summarised, a number of reviews being undertaken by the authors and others are described and some lessons about the applicability of this practice to software engineering are extracted. The basic systematic literature review process seems appropriate to software engineering and the preparation and validation of a review protocol in advance of a review activity is especially valuable. The paper highlights areas where some adaptation of the process to accommodate the domain-specific characteristics of software engineering is needed as well as areas where improvements to current software engineering infrastructure and practices would enhance its applicability. In particular, infrastructure support provided by software engineering indexing databases is inadequate. Also, the quality of abstracts is poor; it is usually not possible to judge the relevance of a study from a review of the abstract alone.},
	pages = {571--583},
	number = {4},
	journaltitle = {Journal of Systems and Software},
	author = {Brereton, Pearl and Kitchenham, Barbara A. and Budgen, David and Turner, Mark and Khalil, Mohamed},
	urldate = {2021-02-22},
	date = {2007-04-01},
	langid = {english},
	keywords = {Empirical software engineering, Systematic literature review},
	file = {ScienceDirect Full Text PDF:files/21/Brereton et al. - 2007 - Lessons from applying the systematic literature re.pdf:application/pdf;ScienceDirect Snapshot:files/22/S016412120600197X.html:text/html},
}

@article{achimugu_systematic_2014,
	title = {A systematic literature review of software requirements prioritization research},
	volume = {56},
	issn = {0950-5849},
	url = {https://www.sciencedirect.com/science/article/pii/S0950584914000354},
	doi = {10.1016/j.infsof.2014.02.001},
	abstract = {Context
During requirements engineering, prioritization is performed to grade or rank requirements in their order of importance and subsequent implementation releases. It is a major step taken in making crucial decisions so as to increase the economic value of a system.
Objective
The purpose of this study is to identify and analyze existing prioritization techniques in the context of the formulated research questions.
Method
Search terms with relevant keywords were used to identify primary studies that relate requirements prioritization classified under journal articles, conference papers, workshops, symposiums, book chapters and {IEEE} bulletins.
Results
73 Primary studies were selected from the search processes. Out of these studies; 13 were journal articles, 35 were conference papers and 8 were workshop papers. Furthermore, contributions from symposiums as well as {IEEE} bulletins were 2 each while the total number of book chapters amounted to 13.
Conclusion
Prioritization has been significantly discussed in the requirements engineering domain. However, it was generally discovered that, existing prioritization techniques suffer from a number of limitations which includes: lack of scalability, methods of dealing with rank updates during requirements evolution, coordination among stakeholders and requirements dependency issues. Also, the applicability of existing techniques in complex and real setting has not been reported yet.},
	pages = {568--585},
	number = {6},
	journaltitle = {Information and Software Technology},
	author = {Achimugu, Philip and Selamat, Ali and Ibrahim, Roliana and Mahrin, Mohd Naz’ri},
	urldate = {2021-02-27},
	date = {2014-06-01},
	langid = {english},
	keywords = {Prioritization, Requirement engineering, Requirements, Software systems, Stakeholders},
	file = {ScienceDirect Snapshot:files/27/S0950584914000354.html:text/html;Achimugu et al. - 2014 - A systematic literature review of software require.pdf:files/30/Achimugu et al. - 2014 - A systematic literature review of software require.pdf:application/pdf},
}

@article{achimugu_systematic_2014-1,
	title = {A systematic literature review of software requirements prioritization research},
	volume = {56},
	issn = {0950-5849},
	url = {https://www.sciencedirect.com/science/article/pii/S0950584914000354},
	doi = {https://doi.org/10.1016/j.infsof.2014.02.001},
	abstract = {Context During requirements engineering, prioritization is performed to grade or rank requirements in their order of importance and subsequent implementation releases. It is a major step taken in making crucial decisions so as to increase the economic value of a system. Objective The purpose of this study is to identify and analyze existing prioritization techniques in the context of the formulated research questions. Method Search terms with relevant keywords were used to identify primary studies that relate requirements prioritization classified under journal articles, conference papers, workshops, symposiums, book chapters and {IEEE} bulletins. Results 73 Primary studies were selected from the search processes. Out of these studies; 13 were journal articles, 35 were conference papers and 8 were workshop papers. Furthermore, contributions from symposiums as well as {IEEE} bulletins were 2 each while the total number of book chapters amounted to 13. Conclusion Prioritization has been significantly discussed in the requirements engineering domain. However, it was generally discovered that, existing prioritization techniques suffer from a number of limitations which includes: lack of scalability, methods of dealing with rank updates during requirements evolution, coordination among stakeholders and requirements dependency issues. Also, the applicability of existing techniques in complex and real setting has not been reported yet.},
	pages = {568--585},
	number = {6},
	journaltitle = {Information and Software Technology},
	author = {Achimugu, Philip and Selamat, Ali and Ibrahim, Roliana and Mahrin, Mohd Naz’ri},
	date = {2014},
	keywords = {Prioritization, Requirement engineering, Requirements, Software systems, Stakeholders},
}

@article{palma_unidosa_2019,
	title = {{UniDoSA}: The Unified Specification and Detection of Service Antipatterns},
	volume = {45},
	issn = {1939-3520},
	doi = {10.1109/TSE.2018.2819180},
	shorttitle = {{UniDoSA}},
	abstract = {Service-based Systems ({SBSs}) are developed on top of diverse Service-Oriented Architecture ({SOA}) technologies or architectural styles. Like any other complex systems, {SBSs} face both functional and non-functional changes at the design or implementation-level. Such changes may degrade the design quality and quality of service ({QoS}) of the services in {SBSs} by introducing poor solutions-service antipatterns. The presence of service antipatterns in {SBSs} may hinder the future maintenance and evolution of {SBSs}. Assessing the quality of design and {QoS} of {SBSs} through the detection of service antipatterns may ease their maintenance and evolution. However, the current literature lacks a unified approach for modelling and evaluating the design of {SBSs} in term of design quality and {QoS}. To address this lack, this paper presents a meta-model unifying the three main service technologies: {REST}, {SCA}, and {SOAP}. Using the meta-model, it describes a unified approach, {UniDoSA} (Unified Specification and Detection of Service Antipatterns), supported by a framework, {SOFA} (Service Oriented Framework for Antipatterns), for modelling and evaluating the design quality and {QoS} of {SBSs}. We apply and validate {UniDoSA} on: (1) 18 {RESTful} {APIs}, (2) two {SCA} systems with more than 150 services, and (3) more than 120 {SOAP} Web services. With a high precision and recall, the detection results provide evidence of the presence of service antipatterns in {SBSs}, which calls for future studies of their impact on {QoS}.},
	pages = {1024--1053},
	number = {10},
	journaltitle = {{IEEE} Transactions on Software Engineering},
	author = {Palma, Francis and Moha, Naouel and Guéhéneuc, Yann-Gaël},
	date = {2019-10},
	note = {Conference Name: {IEEE} Transactions on Software Engineering},
	keywords = {Antipatterns, design, detection, {DSL}, Maintenance engineering, quality of service, Quality of service, {REST}, {SCA}, service-based systems, Service-oriented architecture, Simple object access protocol, {SOAP}, software maintenance and evolution, specification, web services},
	file = {IEEE Xplore Abstract Record:files/34/8325321.html:text/html;IEEE Xplore Full Text PDF:files/35/Palma et al. - 2019 - UniDoSA The Unified Specification and Detection o.pdf:application/pdf},
}

@article{brabra_semantic_2019,
	title = {On semantic detection of cloud {API} (anti)patterns},
	volume = {107},
	issn = {0950-5849},
	url = {https://www.sciencedirect.com/science/article/pii/S095058491830226X},
	doi = {10.1016/j.infsof.2018.10.012},
	abstract = {Context
Open standards are urgently needed for enabling software interoperability in Cloud Computing. Open Cloud Computing Interface ({OCCI}) provides a set of best design principles to create interoperable {REST} management {APIs}. Although {OCCI} is the only standard addressing the management of any kind of cloud resources, it does not support a range of best principles related to {REST} design. This often worsens {REST} {API} quality by decreasing their understandability and reusability.
Objective
We aim at assisting cloud developers to enhance their {REST} management {APIs} by providing a compliance evaluation of {OCCI} and {REST} best principles and a recommendation support to comply with these principles.
Method
First, we leverage patterns and anti-patterns to drive respectively the good and poor practices of {OCCI} and {REST} best principles. Then, we propose a semantic-based approach for defining and detecting {REST} and {OCCI} (anti)patterns and providing a set of correction recommendations to comply with both {REST} and {OCCI} best principles. We validated this approach by applying it on cloud {REST} {APIs} and evaluating its accuracy, usefulness and extensibility.
Results
We found that our approach accurately detects {OCCI} and {REST}(anti)patterns and provides useful recommendations. According to the compliance results, we reveal that there is no widespread adoption of {OCCI} principles in existing {APIs}. In contrast, these {APIs} have reached an acceptable level of maturity regarding {REST} principles.
Conclusion
Our approach provides an effective and extensible technique for defining and detecting {OCCI} and {REST} (anti)patterns in Cloud {REST} {APIs}. Cloud software developers can benefit from our approach and defined principles to accurately evaluate their {APIs} from {OCCI} and {REST} perspectives. This contributes in designing interoperable, understandable, and reusable Cloud management {APIs}. Thank to the compliance analysis and the recommendation support, we also contribute to improving these {APIs}, which make them more straightforward.},
	pages = {65--82},
	journaltitle = {Information and Software Technology},
	author = {Brabra, Hayet and Mtibaa, Achraf and Petrillo, Fabio and Merle, Philippe and Sliman, Layth and Moha, Naouel and Gaaloul, Walid and Guéhéneuc, Yann-Gaël and Benatallah, Boualem and Gargouri, Faïez},
	urldate = {2021-06-08},
	date = {2019-03-01},
	langid = {english},
	keywords = {{REST}, Analysis, Anti-pattern, Cloud computing, Detection, {OCCI}, Ontology, Pattern, Specification},
	file = {ScienceDirect Full Text PDF:files/37/Brabra et al. - 2019 - On semantic detection of cloud API (anti)patterns.pdf:application/pdf;ScienceDirect Snapshot:files/38/S095058491830226X.html:text/html},
}

@inproceedings{palma_are_2015,
	location = {Berlin, Heidelberg},
	title = {Are {RESTful} {APIs} Well-Designed? Detection of their Linguistic (Anti)Patterns},
	isbn = {978-3-662-48616-0},
	doi = {10.1007/978-3-662-48616-0_11},
	series = {Lecture Notes in Computer Science},
	shorttitle = {Are {RESTful} {APIs} Well-Designed?},
	abstract = {Identifier lexicon has a direct impact on software understandability and reusability and, thus, on the quality of the final software product. Understandability and reusability are two important characteristics of software quality. {REST} ({REpresentational} State Transfer) style is becoming a de facto standard adopted by many software organisations. The use of proper lexicon in {RESTful} {APIs} might make them easier to understand and reuse by client developers, and thus, would ease their adoption. Linguistic antipatterns represent poor practices in the naming, documentation, and choice of identifiers in the {APIs} as opposed to linguistic patterns that represent best practices. We present the {DOLAR} approach (Detection Of Linguistic Antipatterns in {REST}), which applies syntactic and semantic analyses for the detection of linguistic (anti)patterns in {RESTful} {APIs}. We provide detailed definitions of ten (anti)patterns and define and apply their detection algorithms on 15 widely-used {RESTful} {APIs}, including Facebook, Twitter, and {YouTube}. The results show that {DOLAR} can indeed detect linguistic (anti)patterns with high accuracy and that they do occur in major {RESTful} {APIs}.},
	pages = {171--187},
	booktitle = {Service-Oriented Computing},
	publisher = {Springer},
	author = {Palma, Francis and Gonzalez-Huerta, Javier and Moha, Naouel and Guéhéneuc, Yann-Gaël and Tremblay, Guy},
	editor = {Barros, Alistair and Grigori, Daniela and Narendra, Nanjangud C. and Dam, Hoa Khanh},
	date = {2015},
	langid = {english},
	keywords = {Antipatterns, {REST}, Detection, Patterns, Semantic analysis},
	file = {Springer Full Text PDF:files/40/Palma et al. - 2015 - Are RESTful APIs Well-Designed Detection of their.pdf:application/pdf},
}

@inproceedings{petrillo_lexical_2018,
	location = {Cham},
	title = {A Lexical and Semantical Analysis on {REST} Cloud Computing {APIs}},
	isbn = {978-3-319-94959-8},
	doi = {10.1007/978-3-319-94959-8_16},
	series = {Communications in Computer and Information Science},
	abstract = {Cloud computing is a popular Internet-based computing paradigm that provides on-demand computational services and resources, generally offered by Cloud providers’ {REpresentational} State Transfer ({REST}) {APIs}. Developers use {REST} {APIs} by invoking these {APIs} by their names and, thus, the lexicons used in the {APIs} are important to ease the developers’ comprehension. In this paper, we study the lexicons and the linguistic (anti)patterns from 16 providers of {REST} Cloud Computing {APIs}. We observe that, although the 16 {REST} {APIs} describe the same domain (Cloud computing), contrary to what one might expect, their lexicons do not share a large number of common terms and 90\% of the terms (3,561/3,947) are just used by one provider. Thus, the {APIs} are lexically heterogeneous and there is not a consensus on which terms to use in Cloud computing. Further, we observe that the majority of the {URIs}, 54\%, follow the Contextualised Resource Names pattern, which is considered a good practice in {REST} {API} design. However, a majority of the {URIs}, 62.82\%, suffer from the Non-pertinent Documentation antipattern. Thus, we present three main contributions: (1) a tooled approach, called {CloudLex}, for extracting and analysing {REST} Cloud computing lexicons; (2) our analysis of the terms used in 16 {REST} {APIs} in 59,677 term occurrences; (3) our analysis of the linguistic (anti)patterns in more than 23,000 {URIs} of the 142 services of the 16 Cloud providers. We also show that {CloudLex} has an average precision of 84.82\%, recall of 63.57\%, and F1-measure of 71.03\% on one complete {API}, Docker Engine, which confirms the accuracy of our semantic analyses for the detection of linguistic (anti)patterns.},
	pages = {308--332},
	booktitle = {Cloud Computing and Service Science},
	publisher = {Springer International Publishing},
	author = {Petrillo, Fabio and Merle, Philippe and Palma, Francis and Moha, Naouel and Guéhéneuc, Yann-Gaël},
	editor = {Ferguson, Donald and Muñoz, Víctor Méndez and Cardoso, Jorge and Helfert, Markus and Pahl, Claus},
	date = {2018},
	langid = {english},
	file = {Springer Full Text PDF:files/42/Petrillo et al. - 2018 - A Lexical and Semantical Analysis on REST Cloud Co.pdf:application/pdf},
}

@article{alshraiedeh_uri_2021,
	title = {A {URI} parsing technique and algorithm for anti-pattern detection in {RESTful} Web services},
	volume = {17},
	issn = {1744-0084, 1744-0084},
	url = {https://www.emerald.com/insight/content/doi/10.1108/IJWIS-08-2020-0052/full/html},
	doi = {10.1108/IJWIS-08-2020-0052},
	abstract = {Purpose
              Many {REpresentational} State Transfer ({RESTful}) Web services suffered from anti-patterns problem, which may diminish the sustainability of the services. The anti-patterns problem could happen in the code of the programme or the uniform resource identifiers ({URIs}) of {RESTful} Web services. This study aims to address the problem by proposing a technique and an algorithm for detecting anti-patterns in {RESTful} Web services. Specifically, the technique is designed based on {URIs} parsing process.
            
            
              Design/methodology/approach
              The study was conducted following the design science research process, which has six activities, namely, identifying problems, identifying solutions, design the solutions, demonstrate the solution, evaluation and communicate the solution. The proposed technique was embedded in an algorithm and evaluated in four phases covering the process of extracting the {URIs}, implementing the anti-pattern detection algorithm, detecting the anti-patterns and validating the results.
            
            
              Findings
              The results of the study suggested an acceptable level of accuracy for the anti-patterns detection with 82.30\% of precision, 87.86\% of recall and 84.93\% of F-measure.
            
            
              Practical implications
              The technique and the algorithm can be used by developers of {RESTful} Web services to detect possible anti-pattern occurrences in the service-based systems.
            
            
              Originality/value
              The technique is personalised to detect amorphous {URI} and ambiguous name anti-patterns in which it scans the Web service {URIs} using specified rules and compares them with pre-determined syntax and corpus.},
	pages = {1--17},
	number = {1},
	journaltitle = {{IJWIS}},
	author = {Alshraiedeh, Fuad Sameh and Katuk, Norliza},
	urldate = {2021-06-08},
	date = {2021-01-23},
	langid = {english},
}

@article{alshraiedeh_uri_2020,
	title = {A {URI} parsing technique and algorithm for anti-pattern detection in {RESTful} Web services},
	volume = {17},
	issn = {1744-0084},
	url = {https://doi.org/10.1108/IJWIS-08-2020-0052},
	doi = {10.1108/IJWIS-08-2020-0052},
	abstract = {Purpose Many {REpresentational} State Transfer ({RESTful}) Web services suffered from anti-patterns problem, which may diminish the sustainability of the services. The anti-patterns problem could happen in the code of the programme or the uniform resource identifiers ({URIs}) of {RESTful} Web services. This study aims to address the problem by proposing a technique and an algorithm for detecting anti-patterns in {RESTful} Web services. Specifically, the technique is designed based on {URIs} parsing process. Design/methodology/approach The study was conducted following the design science research process, which has six activities, namely, identifying problems, identifying solutions, design the solutions, demonstrate the solution, evaluation and communicate the solution. The proposed technique was embedded in an algorithm and evaluated in four phases covering the process of extracting the {URIs}, implementing the anti-pattern detection algorithm, detecting the anti-patterns and validating the results. Findings The results of the study suggested an acceptable level of accuracy for the anti-patterns detection with 82.30\% of precision, 87.86\% of recall and 84.93\% of F-measure. Practical implications The technique and the algorithm can be used by developers of {RESTful} Web services to detect possible anti-pattern occurrences in the service-based systems. Originality/value The technique is personalised to detect amorphous {URI} and ambiguous name anti-patterns in which it scans the Web service {URIs} using specified rules and compares them with pre-determined syntax and corpus.},
	pages = {1--17},
	number = {1},
	journaltitle = {International Journal of Web Information Systems},
	author = {Alshraiedeh, Fuad Sameh and Katuk, Norliza},
	urldate = {2021-06-08},
	date = {2020-01-01},
	note = {Publisher: Emerald Publishing Limited},
	keywords = {Quality of service, Service-oriented architecture, Anti-patterns, Distributed computer systems, Information services, Resource-oriented architecture, Schema, Semantic, Semantic Web, Software architecture, Web services},
	file = {Full Text PDF:files/45/Alshraiedeh and Katuk - 2020 - A URI parsing technique and algorithm for anti-pat.pdf:application/pdf},
}

@article{palma_semantic_2017,
	title = {Semantic Analysis of {RESTful} {APIs} for the Detection of Linguistic Patterns and Antipatterns},
	volume = {26},
	doi = {10.1142/S0218843017420011},
	abstract = {Identifier lexicon may have a direct impact on software understandability and reusability and, thus, on the quality of the final software product. Understandability and reusability are two important characteristics of software quality. {REpresentational} State Transfer ({REST}) style is becoming a de facto standard adopted by software organizations to build their Web applications. Understandable and reusable Uniform Resource Identifers ({URIs}) are important to attract client developers of {RESTful} {APIs} because good {URIs} support the client developers to understand and reuse the {APIs}. Consequently, the use of proper lexicon in {RESTful} {APIs} has also a direct impact on the quality of Web applications that integrate these {APIs}. Linguistic antipatterns represent poor practices in the naming, documentation, and choice of identifiers in the {APIs} as opposed to linguistic patterns that represent the corresponding best practices. In this paper, we present the Semantic Analysis of {RESTful} {APIs} ({SARA}) approach that employs both syntactic and semantic analyses for the detection of linguistic patterns and antipatterns in {RESTful} {APIs}. We provide detailed definitions of 12 linguistic patterns and antipatterns and define and apply their detection algorithms on 18 widely-used {RESTful} {APIs}, including Facebook, Twitter, and Dropbox. Our detection results show that linguistic patterns and antipatterns do occur in major {RESTful} {APIs} in particular in the form of poor documentation practices. Those results also show that {SARA} can detect linguistic patterns and antipatterns with higher accuracy compared to its state-of-the-art approach — {DOLAR}.},
	pages = {1742001},
	journaltitle = {International Journal of Cooperative Information Systems},
	author = {Palma, Francis and Gonzalez-Huerta, Javier and Founi, Mohamed and Moha, Naouel and Tremblay, Guy and Guéhéneuc, Yann-Gaël},
	date = {2017-05-16},
	file = {Full Text PDF:files/47/Palma et al. - 2017 - Semantic Analysis of RESTful APIs for the Detectio.pdf:application/pdf},
}

@inproceedings{palma_detection_2014,
	location = {Berlin, Heidelberg},
	title = {Detection of {REST} Patterns and Antipatterns: A Heuristics-Based Approach},
	isbn = {978-3-662-45391-9},
	doi = {10.1007/978-3-662-45391-9_16},
	series = {Lecture Notes in Computer Science},
	shorttitle = {Detection of {REST} Patterns and Antipatterns},
	abstract = {{REST} ({REpresentational} State Transfer), relying on resources as its architectural unit, is currently a popular architectural choice for building Web-based applications. It is shown that design patterns—good solutions to recurring design problems—improve the design quality and facilitate maintenance and evolution of software systems. Antipatterns, on the other hand, are poor and counter-productive solutions. Therefore, the detection of {REST} (anti)patterns is essential for improving the maintenance and evolution of {RESTful} systems. Until now, however, no approach has been proposed. In this paper, we propose {SODA}-R (Service Oriented Detection for Antipatterns in {REST}), a heuristics-based approach to detect (anti)patterns in {RESTful} systems. We define detection heuristics for eight {REST} antipatterns and five patterns, and perform their detection on a set of 12 widely-used {REST} {APIs} including {BestBuy}, Facebook, and {DropBox}. The results show that {SODA}-R can perform the detection of {REST} (anti)patterns with high accuracy. We also found that Twitter and {DropBox} are not well-designed, i.e., contain more antipatterns. In contrast, Facebook and {BestBuy} are well-designed, i.e., contain more patterns and less antipatterns.},
	pages = {230--244},
	booktitle = {Service-Oriented Computing},
	publisher = {Springer},
	author = {Palma, Francis and Dubois, Johann and Moha, Naouel and Guéhéneuc, Yann-Gaël},
	editor = {Franch, Xavier and Ghose, Aditya K. and Lewis, Grace A. and Bhiri, Sami},
	date = {2014},
	langid = {english},
	keywords = {Antipatterns, {REST}, Detection, Patterns, Design, Heuristics},
	file = {Springer Full Text PDF:files/50/Palma et al. - 2014 - Detection of REST Patterns and Antipatterns A Heu.pdf:application/pdf},
}

@inproceedings{brabra_detecting_2016,
	location = {Cham},
	title = {Detecting Cloud (Anti)Patterns: {OCCI} Perspective},
	isbn = {978-3-319-46295-0},
	doi = {10.1007/978-3-319-46295-0_13},
	series = {Lecture Notes in Computer Science},
	shorttitle = {Detecting Cloud (Anti)Patterns},
	abstract = {Open Cloud Computing Interface ({OCCI}) follows a set of guidelines (i.e. best practices) to create interoperable {APIs} over Cloud resources. In this paper, we identify a set of patterns that must be followed and anti-patterns that should be avoided to comply with the {OCCI} guidelines. To automatically detect (anti)patterns, we propose a Semantic-based approach, relying on {SWRL} (Semantic Web Rule Language) rules and in {SQWRL} (Semantic Query-Enhanced Web Rule Language) queries to describe the (anti)patterns symptoms. An evaluation, conducted on real world Cloud service {APIs}, shows the feasibility of the proposed approach by assessing their compliance to {OCCI} standard.},
	pages = {202--218},
	booktitle = {Service-Oriented Computing},
	publisher = {Springer International Publishing},
	author = {Brabra, Hayet and Mtibaa, Achraf and Sliman, Layth and Gaaloul, Walid and Benatallah, Boualem and Gargouri, Faiez},
	editor = {Sheng, Quan Z. and Stroulia, Eleni and Tata, Samir and Bhiri, Sami},
	date = {2016},
	langid = {english},
	keywords = {Anti-pattern, {OCCI}, Ontology, Pattern, {SQWRL}, {SWRL}},
	file = {Springer Full Text PDF:files/52/Brabra et al. - 2016 - Detecting Cloud (Anti)Patterns OCCI Perspective.pdf:application/pdf},
}

@article{palma_soa_2013,
	title = {{SOA} Antipatterns: an Approach for their Specification and Detection},
	volume = {22},
	doi = {10.1142/S0218843013410049},
	shorttitle = {{SOA} Antipatterns},
	abstract = {Like any other large and complex software systems, Service-Based Systems ({SBSs}) must evolve to fit new user requirements and execution contexts. The changes resulting from the evolution of {SBSs} may degrade their design and quality of service ({QoS}) and may often cause the appearance of common poor solutions in their architecture, called antipatterns, in opposition to design patterns, which are good solutions to recurring problems. Antipatterns resulting from these changes may hinder the future maintenance and evolution of {SBSs}. The detection of antipatterns is thus crucial to assess the design and {QoS} of {SBSs} and facilitate their maintenance and evolution. However, methods and techniques for the detection of antipatterns in {SBSs} are still in their infancy despite their importance. In this paper, we introduce a novel and innovative approach supported by a framework for specifying and detecting antipatterns in {SBSs}. Using our approach, we specify 10 well-known and common antipatterns, including Multi Service and Tiny Service, and automatically generate their detection algorithms. We apply and validate the detection algorithms in terms of precision and recall two systems developed independently, (1) Home-Automation, an {SBS} with 13 services, and (2) {FraSCAti}, an open-source implementation of the Service Component Architecture ({SCA}) standard with more than 100 services. This validation demonstrates that our approach enables the specification and detection of Service Oriented Architecture ({SOA}) antipatterns with an average precision of 90\% and recall of 97.5\%.},
	pages = {1341004},
	journaltitle = {International Journal of Cooperative Information Systems},
	author = {Palma, Francis and Nayrolles, Mathieu and Moha, Naouel and Guéhéneuc, Yann-Gaël and Baudry, Benoit and Jézéquel, Jean-Marc},
	date = {2013-12-01},
	file = {Full Text PDF:files/54/Palma et al. - 2013 - SOA Antipatterns an Approach for their Specificat.pdf:application/pdf},
}

@book{rodriguez_rest_2016,
	title = {{REST} {APIs}: A Large-Scale Analysis of Compliance with Principles and Best Practices},
	isbn = {978-3-319-38790-1},
	shorttitle = {{REST} {APIs}},
	abstract = {Quickly and dominantly, {REST} {APIs} have spread over the Web and percolated into modern software development practice, especially in the Mobile Internet where they conveniently enable offloading data and computations onto cloud services. We analyze more than 78 {GB} of {HTTP} traffic collected by Italy’s biggest Mobile Internet provider over one full day and study how big the trend is in practice, how it changed the traffic that is generated by applications, and how {REST} {APIs} are implemented in practice. The analysis provides insight into the compliance of state-of-the-art {APIs} with theoretical Web engineering principles and guidelines, knowledge that affects how applications should be developed to be scalable and robust. The perspective is that of the Mobile Internet.},
	pagetotal = {21},
	author = {Rodriguez, Carlos and Baez, Marcos and Daniel, Florian and Casati, Fabio and Trabucco, Juan and Canali, Luigi and Percannella, Gianraffaele},
	date = {2016-06-06},
	doi = {10.1007/978-3-319-38791-8_2},
	note = {Pages: 39},
	file = {Full Text PDF:files/57/Rodriguez et al. - 2016 - REST APIs A Large-Scale Analysis of Compliance wi.pdf:application/pdf},
}

@inproceedings{petrillo_are_2016,
	location = {Cham},
	title = {Are {REST} {APIs} for Cloud Computing Well-Designed? An Exploratory Study},
	isbn = {978-3-319-46295-0},
	doi = {10.1007/978-3-319-46295-0_10},
	series = {Lecture Notes in Computer Science},
	shorttitle = {Are {REST} {APIs} for Cloud Computing Well-Designed?},
	abstract = {Cloud computing is currently the most popular model to offer and access computational resources and services. Many cloud providers use the {REST} architectural style (Representational State Transfer) for offering such computational resources. However, these cloud providers face challenges when designing and exposing {REST} {APIs} that are easy to handle by end-users and/or developers. Yet, they benefit from best practices to help them design understandable and reusable {REST} {APIs}.However, these best practices are scattered in the literature and they have not be studied systematically on real-world {APIs}. Consequently, we propose two contributions. In our first contribution, we survey the literature and compile a catalog of 73 best practices in the design of {REST} {APIs} making {APIs} more understandable and reusable. In our second contribution, we perform a study of three different and well-known {REST} {APIs} from three cloud providers to investigate how their {APIs} are offered and accessed. These cloud providers are Google Cloud Platform, {OpenStack}, and Open Cloud Computing Interface ({OCCI}). In particular, we evaluate the coverage of the features provided by the {REST} {APIs} of these cloud providers and their conformance with the best practices for {REST} {APIs} design.Our results show that Google Cloud follows 66 \% (48/73), {OpenStack} follows 62 \% (45/73), and {OCCI} 1.2 follows 56 \% (41/73) of the best practices. Second, although these numbers are not necessarily high, partly because of the strict and precise specification of best practices, we showed that cloud {APIs} reach an acceptable level of maturity.},
	pages = {157--170},
	booktitle = {Service-Oriented Computing},
	publisher = {Springer International Publishing},
	author = {Petrillo, Fabio and Merle, Philippe and Moha, Naouel and Guéhéneuc, Yann-Gaël},
	editor = {Sheng, Quan Z. and Stroulia, Eleni and Tata, Samir and Bhiri, Sami},
	date = {2016},
	langid = {english},
	keywords = {Cloud Computing, Cloud Platform, Cloud Provider, Cloud Service, Software Define Network},
	file = {Springer Full Text PDF:files/60/Petrillo et al. - 2016 - Are REST APIs for Cloud Computing Well-Designed A.pdf:application/pdf},
}

@inproceedings{moha_specification_2012,
	location = {Berlin, Heidelberg},
	title = {Specification and Detection of {SOA} Antipatterns},
	isbn = {978-3-642-34321-6},
	doi = {10.1007/978-3-642-34321-6_1},
	series = {Lecture Notes in Computer Science},
	abstract = {Like any other complex software system, Service Based Systems ({SBSs}) must evolve to fit new user requirements and execution contexts. The changes resulting from the evolution of {SBSs} may degrade their design and quality of service ({QoS}) and may often cause the appearance of common poor solutions, called Antipatterns. Antipatterns resulting from these changes also hinder the future maintenance and evolution of {SBSs}. The automatic detection of antipatterns is thus important to assess the design and {QoS} of {SBSs} and ease their maintenance and evolution. However, methods and techniques for the detection of antipatterns in {SBSs} are still in their infancy despite their importance. In this paper, we introduce a novel and innovative approach supported by a framework for specifying and detecting antipatterns in {SBSs}. Using our approach, we specify 10 well-known and common antipatterns, including Multi Service and Tiny Service, and we automatically generate their detection algorithms. We apply and validate the detection algorithms in terms of precision and recall on Home-Automation, an {SBS} developed independently. This validation demonstrates that our approach enables the specification and detection of {SOA} antipatterns with the precision of more than 90\% and the recall of 100\%.},
	pages = {1--16},
	booktitle = {Service-Oriented Computing},
	publisher = {Springer},
	author = {Moha, Naouel and Palma, Francis and Nayrolles, Mathieu and Conseil, Benjamin Joyen and Guéhéneuc, Yann-Gaël and Baudry, Benoit and Jézéquel, Jean-Marc},
	editor = {Liu, Chengfei and Ludwig, Heiko and Toumani, Farouk and Yu, Qi},
	date = {2012},
	langid = {english},
	keywords = {Antipatterns, Quality of service, Detection, Specification, Design, Service based systems, Software evolution and maintenance},
	file = {Springer Full Text PDF:files/62/Moha et al. - 2012 - Specification and Detection of SOA Antipatterns.pdf:application/pdf},
}

@inproceedings{zhou_rest_2014,
	title = {{REST} {API} Design Patterns for {SDN} Northbound {API}},
	doi = {10.1109/WAINA.2014.153},
	abstract = {{REST} architectural style gains increasing popularity in the networking protocol design, and it has become a prevalent choice for northbound {API} of Software-Defined Networking ({SDN}). This paper addresses many critical issues in {RESTful} networking protocol design, and presents a framework on how a networking protocol can be designed in a truly {RESTful} manner, making it towards a service oriented data networking. In particular, we introduce the {HTTP} content negotiation mechanism which allows clients to select different representation formats from the same resource {URI}. Most importantly, we present a hypertext-driven approach, so that hypertext links are defined between {REST} resources for the networking protocol to guide clients to identify the right resources rather than relying on fixed resource {URIs}. The advantages of our approach are verified in two folds. First, we show how to apply our approach to fix {REST} design problems in some existing northbound networking {APIs}, and then we show how to design a {RESTful} northbound {API} of {SDN} in the context of {OpenStack}. We implemented our proposed approach in the northbound {REST} {API} of {SOX}, a generalized {SDN} controller, and the benefits of the proposed approach are experimentally verified.},
	eventtitle = {2014 28th International Conference on Advanced Information Networking and Applications Workshops},
	pages = {358--365},
	booktitle = {2014 28th International Conference on Advanced Information Networking and Applications Workshops},
	author = {Zhou, Wei and Li, Li and Luo, Min and Chou, Wu},
	date = {2014-05},
	keywords = {Computer architecture, Controller, Firewalls (computing), Hypertext Driven, Media, Northbound {API}, {OpenStack}, Ports (Computers), Protocols, Quantum, {REST} {API}, {SDN}, Servers, {XML}},
	file = {IEEE Xplore Full Text PDF:files/64/Zhou et al. - 2014 - REST API Design Patterns for SDN Northbound API.pdf:application/pdf;IEEE Xplore Abstract Record:files/65/6844664.html:text/html},
}

@inproceedings{petrillo_towards_2017,
	location = {Porto, Portugal},
	title = {Towards a {REST} Cloud Computing Lexicon:},
	isbn = {978-989-758-243-1},
	url = {http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0006281203760383},
	doi = {10.5220/0006281203760383},
	shorttitle = {Towards a {REST} Cloud Computing Lexicon},
	eventtitle = {7th International Conference on Cloud Computing and Services Science},
	pages = {376--383},
	booktitle = {Proceedings of the 7th International Conference on Cloud Computing and Services Science},
	publisher = {{SCITEPRESS} - Science and Technology Publications},
	author = {Petrillo, Fabio and Merle, Philippe and Moha, Naouel and Guéhéneuc, Yann-Gaël},
	urldate = {2021-06-08},
	date = {2017},
	langid = {english},
	file = {Petrillo et al. - 2017 - Towards a REST Cloud Computing Lexicon.pdf:files/66/Petrillo et al. - 2017 - Towards a REST Cloud Computing Lexicon.pdf:application/pdf},
}

@book{petrillo_towards_2017-1,
	title = {Towards a {REST} Cloud Computing Lexicon},
	abstract = {Cloud computing is a popular Internet-based computing paradigm that provides on-demand computational services and resources, generally offered by cloud providers' {REpresentational} State Transfer ({REST}) {APIs}. To the best of our knowledge, there has been no study on the analysis of the lexicon adopted by cloud providers, despite its importance for developers. In this paper, we studied three different and well-known {REST} {APIs} (Google Cloud Platform, {OpenStack}, and Open Cloud Computing Interface) to investigate and organise their lexicons. This study presents three main contributions: 1) a tooled approach, called {CloudLex}, for extracting and analysing {REST} cloud computing lexicons, 2) a dataset of services, resources, and terms used in the three studied {REST} {APIs}, 3) our analysis of this dataset, which represents a first attempt to provide a common {REST} cloud computing lexicon. After analysing our dataset, we observe that although the three studied {REST} {APIs} to describe the same domain (cloud computing), contrary to what one might expect, they do not share a large number of common terms, and only 5\% of terms (17/352) are shared by two providers. Thus, the three {APIs} are lexically heterogeneous, and there is not a consensus on which terms to use on cloud computing systems. We discuss new avenues for cloud computing {API} designers and researchers.},
	pagetotal = {376},
	author = {Petrillo, Fabio and Merle, Philippe and Moha, Naouel and Guéhéneuc, Yann-Gaël},
	date = {2017-01-01},
	doi = {10.5220/0006281203760383},
	note = {Pages: 383},
	file = {Full Text PDF:files/69/Petrillo et al. - 2017 - Towards a REST Cloud Computing Lexicon.pdf:application/pdf},
}

@inproceedings{aghajani_large-scale_2018,
	title = {A Large-Scale Empirical Study on Linguistic Antipatterns Affecting {APIs}},
	doi = {10.1109/ICSME.2018.00012},
	abstract = {The concept of monolithic stand-alone software systems developed completely from scratch has become obsolete, as modern systems nowadays leverage the abundant presence of Application Programming Interfaces ({APIs}) developed by third parties, which leads on the one hand to accelerated development, but on the other hand introduces potentially fragile dependencies on external resources. In this context, the design of any {API} strongly influences how developers write code utilizing it. A wrong design decision like a poorly chosen method name can lead to a steeper learning curve, due to misunderstandings, misuse and eventually bug-prone code in the client projects using the {API}. It is not unfrequent to find {APIs} with poorly expressive or misleading names, possibly lacking appropriate documentation. Such issues can manifest in what have been defined in the literature as Linguistic Antipatterns ({LAs}), i.e., inconsistencies among the naming, documentation, and implementation of a code entity. While previous studies showed the relevance of {LAs} for software developers, their impact on (developers of) client projects using {APIs} affected by {LAs} has not been investigated. This paper fills this gap by presenting a large-scale study conducted on 1.6k releases of popular Maven libraries, 14k open-source Java projects using these libraries, and 4.4k questions related to the investigated {APIs} asked on Stack Overflow. In particular, we investigate whether developers of client projects have higher chances of introducing bugs when using {APIs} affected by {LAs} and if these trigger more questions on Stack Overflow as compared to non-affected {APIs}.},
	eventtitle = {2018 {IEEE} International Conference on Software Maintenance and Evolution ({ICSME})},
	pages = {25--35},
	booktitle = {2018 {IEEE} International Conference on Software Maintenance and Evolution ({ICSME})},
	author = {Aghajani, Emad and Nagy, Csaba and Bavota, Gabriele and Lanza, Michele},
	date = {2018-09},
	note = {{ISSN}: 2576-3148},
	keywords = {Documentation, Application Programming Interfaces ({APIs}), Computer bugs, Empirical Study, Libraries, Linguistic Antipatterns, Linguistics, Tools, Usability},
	file = {IEEE Xplore Full Text PDF:files/72/Aghajani et al. - 2018 - A Large-Scale Empirical Study on Linguistic Antipa.pdf:application/pdf},
}

@inproceedings{nayrolles_improving_2013,
	title = {Improving {SOA} antipatterns detection in Service Based Systems by mining execution traces},
	doi = {10.1109/WCRE.2013.6671307},
	abstract = {Service Based Systems ({SBSs}), like other software systems, evolve due to changes in both user requirements and execution contexts. Continuous evolution could easily deteriorate the design and reduce the Quality of Service ({QoS}) of {SBSs} and may result in poor design solutions, commonly known as {SOA} antipatterns. {SOA} antipatterns lead to a reduced maintainability and reusability of {SBSs}. It is therefore important to first detect and then remove them. However, techniques for {SOA} antipattern detection are still in their infancy, and there are hardly any tools for their automatic detection. In this paper, we propose a new and innovative approach for {SOA} antipattern detection called {SOMAD} (Service Oriented Mining for Antipattern Detection) which is an evolution of the previously published {SODA} (Service Oriented Detection For Antpatterns) tool. {SOMAD} improves {SOA} antipattern detection by mining execution traces: It detects strong associations between sequences of service/method calls and further filters them using a suite of dedicated metrics. We first present the underlying association mining model and introduce the {SBS}-oriented rule metrics. We then describe a validating application of {SOMAD} to two independently developed {SBSs}. A comparison of our new tool with {SODA} reveals superiority of the former: Its precision is better by a margin ranging from 2.6\% to 16.67\% while the recall remains optimal at 100\% and the speed is significantly reduces (2.5+ times on the same test subjects).},
	eventtitle = {2013 20th Working Conference on Reverse Engineering ({WCRE})},
	pages = {321--330},
	booktitle = {2013 20th Working Conference on Reverse Engineering ({WCRE})},
	author = {Nayrolles, Mathieu and Moha, Naouel and Valtchev, Petko},
	date = {2013-10},
	note = {{ISSN}: 2375-5369},
	keywords = {Service-oriented architecture, Association rules, Couplings, Detection algorithms, Measurement, Mining Execution Traces, Scattering, Sequential Association Rules, Service Oriented Architecture, {SOA} Antipatterns},
	file = {IEEE Xplore Full Text PDF:files/74/Nayrolles et al. - 2013 - Improving SOA antipatterns detection in Service Ba.pdf:application/pdf},
}

@inproceedings{haupt_framework_2017,
	title = {A Framework for the Structural Analysis of {REST} {APIs}},
	doi = {10.1109/ICSA.2017.40},
	abstract = {Today, {REST} {APIs} have established as a means for realizing distributed systems and are supposed to gain even more importance in the context of Cloud Computing, Internet of Things, and Microservices. Nevertheless, many existing {REST} {APIs} are known to be not well-designed, resulting in the absence of desirable quality attributes that truly {RESTful} systems entail. Although existing analysis show, that many {REST} {APIs} are not fully {REST} compliant, it is still an open issue how to improve this deficit and where to start. In this work, we introduce a framework for the structural analysis of {REST} {APIs} based on their description documents, as this allows for a comprehensive, well-structured analysis approach that also includes analyzing the corresponding {API} description languages. A first validation builds on a set of 286 real world {API} descriptions available as Swagger documents, and comprises their transformation into a canonical metamodel for {REST} {APIs} as well as a metrics-based analysis and discussion of their structural characteristics with respect to compliance with the {REST} architectural style.},
	eventtitle = {2017 {IEEE} International Conference on Software Architecture ({ICSA})},
	pages = {55--58},
	booktitle = {2017 {IEEE} International Conference on Software Architecture ({ICSA})},
	author = {Haupt, Florian and Leymann, Frank and Scherer, Anton and Vukojevic-Haupt, Karolina},
	date = {2017-04},
	keywords = {Google, {REST}, Cloud computing, Protocols, Measurement, analysis, Analytical models, Best practices, interface description language, Transforms},
	file = {IEEE Xplore Full Text PDF:files/76/Haupt et al. - 2017 - A Framework for the Structural Analysis of REST AP.pdf:application/pdf;IEEE Xplore Abstract Record:files/77/7930199.html:text/html},
}

@inproceedings{belkhir_observational_2019,
	title = {An Observational Study on the State of {REST} {API} Uses in Android Mobile Applications},
	doi = {10.1109/MOBILESoft.2019.00020},
	abstract = {{REST} is by far the most commonly-used style for designing {APIs}, especially for mobile platforms. Indeed, {REST} {APIs} are well suited for providing content to apps running on small devices, like smart-phones and tablets. Several research works studied {REST} {APIs} development practices for mobile apps. However, little is known about how Android apps use/consume these {APIs} in practice through {HTTP} client libraries. Consequently, we propose an observational study on the state of the practice of {REST} {APIs} use in Android mobile apps. We (1) build a catalogue of Android {REST} mobile clients practices; (2) define each of these practices through a number of heuristics based on their potential implementations in Android apps, and (3) propose an automatic approach to detect these practices. We analyze 1,595 {REST} mobile apps downloaded from the Google Play Store and mine thousands of {StackOverflow} posts to study {REST} {APIs} uses in Android apps. We observe that developers have always used {HttpURLConnection} class for {REST} {APIs} implementation in Android apps. However, since the apparition of {REST} third-party libraries such as Okhttp, Retrofit and Google Volley, Android {REST} clients have been increasingly relying on the facilities offered by these libraries. Also, we observe that developers used to ignore some good practices of {REST} {APIs} uses in Android apps. Such practices are the use of {HTTP} third-party libraries, caching responses, timeout management, and error handling. Moreover, we report that only two good practices are widely considered by Android developers when implementing their mobile apps. These practices are network connectivity awareness and {JSON} vs. {XML} response parsing. We also find that Retrofit is the most targeted third-party {HTTP} client library by Android developers because of its ease of use and provided features. Thus, we conclude that service providers must strive to make their libraries as simple as possible while mobile-service consumers should consider existing libraries to benefit from their features, such as asynchronous requests, awareness to connectivity, timeout management, and cached responses.},
	eventtitle = {2019 {IEEE}/{ACM} 6th International Conference on Mobile Software Engineering and Systems ({MOBILESoft})},
	pages = {66--75},
	booktitle = {2019 {IEEE}/{ACM} 6th International Conference on Mobile Software Engineering and Systems ({MOBILESoft})},
	author = {Belkhir, Abdelkarim and Abdellatif, Manel and Tighilt, Rafik and Moha, Naouel and Guéhéneuc, Yann-Gaël and Beaudry, Éric},
	date = {2019-05},
	keywords = {Google, {REST}, {XML}, Libraries, Tools, Best practices, Android, {API}, Batteries, Client, Mobile, Mobile applications, Practices},
	file = {IEEE Xplore Full Text PDF:files/79/Belkhir et al. - 2019 - An Observational Study on the State of REST API Us.pdf:application/pdf},
}

@inproceedings{oumaziz_empirical_2017,
	location = {Cham},
	title = {Empirical Study on {REST} {APIs} Usage in Android Mobile Applications},
	isbn = {978-3-319-69035-3},
	doi = {10.1007/978-3-319-69035-3_45},
	series = {Lecture Notes in Computer Science},
	abstract = {A large set of mobile applications (apps) heavily rely on services accessible through the Web via {REST} {APIs}. However, the way mobile apps use services in practice has never been studied. In this paper, we perform an empirical study in the Android ecosystem in which we analyze 500 popular apps and 15 popular services. We also conducted an online survey to identify best practices for Android developers. Our results show that they generally favor invoking services by using official service libraries instead of invoking services with a generic {HTTP} client. We also present which good practices service libraries should implement.},
	pages = {614--622},
	booktitle = {Service-Oriented Computing},
	publisher = {Springer International Publishing},
	author = {Oumaziz, Mohamed A. and Belkhir, Abdelkarim and Vacher, Tristan and Beaudry, Eric and Blanc, Xavier and Falleri, Jean-Rémy and Moha, Naouel},
	editor = {Maximilien, Michael and Vallecillo, Antonio and Wang, Jianmin and Oriol, Marc},
	date = {2017},
	langid = {english},
	keywords = {{REST} {API}, Android, Mobile applications, Empirical study, Rest services},
	file = {Springer Full Text PDF:files/81/Oumaziz et al. - 2017 - Empirical Study on REST APIs Usage in Android Mobi.pdf:application/pdf},
}

@article{alshraideh_soap_2019,
	title = {{SOAP} and {RESTful} web service anti-patterns: A scoping review},
	volume = {8},
	doi = {10.30534/ijatcse/2019/05852019},
	shorttitle = {{SOAP} and {RESTful} web service anti-patterns},
	abstract = {Web services provide a uniform framework to achieve a high level of interaction between distributed heterogeneous software systems and data resources shared over the Internet. Producing a well-designed web service is significant because it leads to a more understandable service and a higher level of interaction and leads to effective software maintainability. However, web service is suffering from a poor design problem named anti-patterns. Analysis of the literature returned a plethora of studies on anti-patterns that caused difficulties for developers to synthesize and summarized the possible types of anti-patterns and further comprehend each of them. Due to this limitation, this paper aims to provide organized literature on the types of anti-patterns found in web services. A scoping review was conducted by searching scholarly documents, analyzing, and classified them based on their anti-pattern types. The review provided in this paper could be used as a guide for developers to identify the anti-patterns that could be found in web services.},
	pages = {1831--1840},
	journaltitle = {International Journal of Advanced Trends in Computer Science and Engineering},
	author = {Alshraideh, Fuad and Katuk, Norliza},
	date = {2019-10-05},
	file = {Full Text PDF:files/83/Alshraideh and Katuk - 2019 - SOAP and RESTful web service anti-patterns A scop.pdf:application/pdf},
}

@misc{keele_et_al_guidelines_nodate,
	title = {Guidelines for performing Systematic Literature Reviews in Software Engineering},
	author = {Keele et al.},
	file = {Guidelines for performing Systematic Literature Reviews in Software Engineering.pdf:files/6/Guidelines for performing Systematic Literature Reviews in Software Engineering.pdf:application/pdf},
}

@inproceedings{atlidakis_restler_2019,
	title = {{RESTler}: Stateful {REST} {API} Fuzzing},
	url = {https://www.microsoft.com/en-us/research/publication/restler-stateful-rest-api-fuzzing/},
	shorttitle = {{RESTler}},
	abstract = {This paper introduces {RESTler}, the first stateful {REST} {API} fuzzer. {RESTler} analyzes the {API} specification of a cloud service and generates sequences of requests that automatically test the service through its {API}. {RESTler} generates test sequences by (1) inferring producer-consumer dependencies among request types declared in the specification (e.g., inferring that “a request B should […]},
	eventtitle = {{ICSE} 2019},
	author = {Atlidakis, Vaggelis and Godefroid, Patrice and Polishchuk, Marina},
	urldate = {2021-07-21},
	date = {2019-11-01},
	langid = {american},
	file = {Snapshot:files/87/restler-stateful-rest-api-fuzzing.html:text/html},
}

@inproceedings{atlidakis_restler_2019-1,
	location = {Montreal, {QC}, Canada},
	title = {{RESTler}: Stateful {REST} {API} Fuzzing},
	isbn = {978-1-72810-869-8},
	url = {https://ieeexplore.ieee.org/document/8811961/},
	doi = {10.1109/ICSE.2019.00083},
	shorttitle = {{RESTler}},
	abstract = {This paper introduces {RESTler}, the ﬁrst stateful {REST} {API} fuzzer. {RESTler} analyzes the {API} speciﬁcation of a cloud service and generates sequences of requests that automatically test the service through its {API}. {RESTler} generates test sequences by (1) inferring producer-consumer dependencies among request types declared in the speciﬁcation (e.g., inferring that “a request B should be executed after request A” because B takes as an input a resource-id x produced by A) and by (2) analyzing dynamic feedback from responses observed during prior test executions in order to generate new tests (e.g., learning that “a request C after a request sequence A;B is refused by the service” and therefore avoiding this combination in the future). We present experimental results showing that these two techniques are necessary to thoroughly exercise a service under test while pruning the large search space of possible request sequences. We used {RESTler} to test {GitLab}, an open-source Git service, as well as several Microsoft Azure and Ofﬁce365 cloud services. {RESTler} found 28 bugs in {GitLab} and several bugs in each of the Azure and Ofﬁce365 cloud services tested so far. These bugs have been conﬁrmed and ﬁxed by the service owners.},
	eventtitle = {2019 {IEEE}/{ACM} 41st International Conference on Software Engineering ({ICSE})},
	pages = {748--758},
	booktitle = {2019 {IEEE}/{ACM} 41st International Conference on Software Engineering ({ICSE})},
	publisher = {{IEEE}},
	author = {Atlidakis, Vaggelis and Godefroid, Patrice and Polishchuk, Marina},
	urldate = {2021-07-21},
	date = {2019-05},
	langid = {english},
	file = {Atlidakis et al. - 2019 - RESTler Stateful REST API Fuzzing.pdf:files/88/Atlidakis et al. - 2019 - RESTler Stateful REST API Fuzzing.pdf:application/pdf},
}

@inproceedings{atlidakis_restler_2019-2,
	title = {{RESTler}: Stateful {REST} {API} Fuzzing},
	url = {https://www.microsoft.com/en-us/research/publication/restler-stateful-rest-api-fuzzing/},
	shorttitle = {{RESTler}},
	abstract = {This paper introduces {RESTler}, the first stateful {REST} {API} fuzzer. {RESTler} analyzes the {API} specification of a cloud service and generates sequences of requests that automatically test the service through its {API}. {RESTler} generates test sequences by (1) inferring producer-consumer dependencies among request types declared in the specification (e.g., inferring that “a request B should […]},
	eventtitle = {{ICSE} 2019},
	author = {Atlidakis, Vaggelis and Godefroid, Patrice and Polishchuk, Marina},
	urldate = {2021-07-21},
	date = {2019-11-01},
	langid = {american},
}